;
; lab4.1.asm
;
; Created: 12/12/2021 2:14:04 PM
; Author : PaterakisA
;


.include "m16def.inc"

.def blink_state = r16
.def led_state = r17
.def welcome_active = r18

.DSEG
  _tmp_: .BYTE 2
.CSEG

;Sets PB7 on | keeps gas level
.macro set_on
  ori r17,0x80
  out PORTB,r17
.endm

;Sets PB7 off | keeps gas level
.macro set_off
  andi r17,0x7F
  out PORTB,r17
.endm


.macro success
	ldi welcome_active, 0x01 ;Set flag starting correct pass
	rcall lcd_init_sim
  	ldi r24, 'W'
  	rcall lcd_data_sim
  	ldi r24, 'E'
  	rcall lcd_data_sim
  	ldi r24, 'L'
  	rcall lcd_data_sim
  	ldi r24, 'C'
  	rcall lcd_data_sim
  	ldi r24, 'O'
  	rcall lcd_data_sim
  	ldi r24, 'M'
  	rcall lcd_data_sim
  	ldi r24, 'E'
  	rcall lcd_data_sim
  	ldi r24, ' '
  	rcall lcd_data_sim
  	ldi r24, '1'
  	rcall lcd_data_sim
  	ldi r24, '2'
  	rcall lcd_data_sim     ;print Welcome and set leds
  	set_on
  	ldi r24,low(4000)
  	ldi r25,high(4000)
  	rcall wait_msec        ;wait 4 seconds
  	set_off                ;turn PB7 OFF
	ldi r24,0x01
	rcall lcd_command_sim    ;Clear LCD
	ldi r24,low(1530)
	ldi r25,high(1530)
	rcall wait_usec          ;wait 1.5ms to avoid problems
  ldi welcome_active, 0x00  ;reset flag exiting correct pass
.endm

.macro wrong
	ldi r21,0x04             ;set for loop
  seconds:
  	set_on                 ;turn on PB7 , no override
  	ldi r24,low(500)
  	ldi r25,high(500)
  	rcall wait_msec        ;wait .5 sec
  	set_off                ;turn off PB7, no override
  	ldi r24,low(500)
  	ldi r25,high(500)
  	rcall wait_msec        ;wait .5 sec
  	dec r21                ;1 second elapsed, iterate loop
  	cpi r21,0x00           ;when r21 resets end the macro
  	brne seconds
.endm

;Display gas warning
.macro display_gas
  rcall lcd_init_sim
  ldi r24, 'G' ; gas message
  rcall lcd_data_sim
  ldi r24, 'A'
  rcall lcd_data_sim
  ldi r24, 'S'
  rcall lcd_data_sim
  ldi r24, ' '
  rcall lcd_data_sim
  ldi r24, 'D'
  rcall lcd_data_sim
  ldi r24, 'E'
  rcall lcd_data_sim
  ldi r24, 'T'
  rcall lcd_data_sim
  ldi r24, 'E'
  rcall lcd_data_sim
  ldi r24, 'C'
  rcall lcd_data_sim
  ldi r24, 'T'
  rcall lcd_data_sim
  ldi r24, 'E'
  rcall lcd_data_sim
  ldi r24, 'D'
  rcall lcd_data_sim
.endm

;display Clear notification
.macro display_clear
  rcall lcd_init_sim
  ldi r24, 'C' ; clear message
  rcall lcd_data_sim
  ldi r24, 'L'
  rcall lcd_data_sim
  ldi r24, 'E'
  rcall lcd_data_sim
  ldi r24, 'A'
  rcall lcd_data_sim
  ldi r24, 'R'
  rcall lcd_data_sim
.endm



.org 0x0

jmp reset
.org 0x10
rjmp ISR_TIMER1_OVF
.org 0x1c
rjmp ADC_ISR


reset:
  ldi r24,low(RAMEND)
  out SPL,r24
  ldi r25,high(RAMEND)
  out SPH,r25             ;initialize stack pointers
  clr r24
  clr blink_state
  clr led_state
  clr welcome_active      ;reset all flags to be used
  ser r24
  out DDRB,r24; port B for output
  out DDRD,r24; port D for output
  clr r24

  ldi r24, (1 << PC7) | (1 << PC6) | (1 << PC5) | (1 << PC4)
  out DDRC, r24 ;initialize for keyboard reading

  rcall ADC_init ;initialize adc converter
  ldi r24, (1 << TOIE1) ;enable interrupt overflow of timer1
  out TIMSK,r24
  ldi r24, (1<<CS12) | (0<<CS11) | (1<<CS10) ;CK/1024
  out TCCR1B,r24
  ldi r24,0xfc
  out TCNT1H,r24
  ldi r24 ,0xf3   ;interrupt every 100 ms
  out TCNT1L ,r24
  sei ;enable interrupts

num1:
  ldi r24,0xF0
  rcall scan_keypad_rising_edge_sim
  clr r20
  or r20,r24
  or r20,r25
  cpi r20,0 ;if r20 is 0 after (or) then there was no change in the numbers aka repeat
  breq num1
  cpi r25,0x10 ; num1 must be 1 aka r25 = 0001 0000 => 10H = 16D r24 = 0
  brne wrong_num1
  cpi r24,0  ;r24 = 0
  brne wrong_num1
  rjmp num2

wrong_num1:
  ldi r21,1   ;set flag on wrong num1

num2:
  ldi r24,0xF0
  rcall scan_keypad_rising_edge_sim
  clr r20
  or r20,r24
  or r20,r25
  cpi r20,0 ;if r20 is 0 after or  then there was no change in the numbers aka repeat
  breq num2

  cpi r21,1   ;if num1 flag is set there is no point checking num2
  breq wrong_pass

  cpi r25,0x20 ; num2 must be 2 aka r25 = 0010 0000 => 20H = 32D r24 = 0
  brne wrong_pass
  cpi r24,0  ;r24 = 0
  brne wrong_pass
  success     ;call success if nums passed the checks (then INPUT: 12)
  rjmp num1   ;restart

wrong_pass:
  wrong
  rjmp num1

wait_usec:
	sbiw r24,1
	nop
	nop
	nop
	nop
	brne wait_usec
ret

wait_msec:
	push r24
	push r25
	ldi r24,low(998)
	ldi r25,high(998)
	rcall wait_usec
	pop r25
	pop r24
	sbiw r24,1
	brne wait_msec
ret

scan_row_sim:
	out PORTC, r25 ;this is line picker
	push r24
	push r25
	ldi r24,low(500)
	ldi r25,high(500)
	rcall wait_usec
	pop r25
	pop r24
	nop
	nop ;nop is used to cylce twice so there can be a position change
	in r24,PINC
	andi r24,0x0F;as with  before we picked a column and we read the column's number pressed.
ret

scan_keypad_sim:
	push r26
	push r27
	ldi r25, (1 << PC4) ;lets start with PC4
	rcall scan_row_sim
	swap r24  ;PC4 is on top 4 MSB
	mov r27,r24 ;save the input
	ldi r25, (1 << PC5)
	rcall scan_row_sim
	add r27,r24 ;            r27 is now MSB(PC4),LSB(PC5)
	ldi r25, (1 << PC6)
	rcall scan_row_sim
	swap r24
	mov r26,r24
	ldi r25, (1 << PC7)
	rcall scan_row_sim
	add r26,r24	;			r26 is now MSB(PC6),LSB(PC7)
	movw r24,r26 ;transfer results to 24-25 pair
	pop r27
	pop r26
ret

scan_keypad_rising_edge_sim:
	push r22 ; ?????????? ???? ??????????? r23:r22 ??? ????
	push r23 ; r26:r27 ????? ???? ????????? ???? ???? ???????
	push r26
	push r27
	rcall scan_keypad_sim ; ?????? ?? ???????????? ??? ?????????? ?????????
	push r24 ; ??? ?????????? ?? ??????????
	push r25
	ldi r24 ,15 ; ??????????? 15 ms (??????? ????? 10-20 msec ??? ??????????? ??? ???
	ldi r25 ,0 ; ???????????? ??? ????????????? ? ????????????? ????????????)
	rcall wait_msec
	rcall scan_keypad_sim ; ?????? ?? ???????????? ???? ??? ????????
	pop r23 ; ??? ??????? ?????????? ???????????
	pop r22
	and r24 ,r22
	and r25 ,r23
	ldi r26 ,low(_tmp_) ; ??????? ??? ????????? ??? ????????? ????
	ldi r27 ,high(_tmp_) ; ??????????? ????? ??? ???????? ????? r27:r26
	ld r23 ,X+
	ld r22 ,X
	st X ,r24 ; ?????????? ??? RAM ?? ??? ?????????
	st -X ,r25 ; ??? ?????????
	com r23
	com r22 ; ???? ???? ????????? ??? ????? ??????? ???????
	and r24 ,r22
	and r25 ,r23
	pop r27 ; ????????? ???? ??????????? r27:r26
	pop r26 ; ??? r23:r22
	pop r23
	pop r22
ret

keypad_to_ascii_sim:
	push r26 ; ?????????? ???? ??????????? r27:r26 ????? ????
	push r27 ; ????????? ???? ??? ???????
	movw r26 ,r24 ; ?????? ?1? ???? ?????? ??? ?????????? r26 ????????
	; ?? ???????? ??????? ??? ????????
	ldi r24 ,'*'
	; r26
	;C 9 8 7 D # 0 *
	sbrc r26 ,0
	rjmp return_ascii
	ldi r24 ,'0'
	sbrc r26 ,1
	rjmp return_ascii
	ldi r24 ,'#'
	sbrc r26 ,2
	rjmp return_ascii
	ldi r24 ,'D'
	sbrc r26 ,3 ; ?? ??? ????? ?1???????????? ??? ret, ?????? (?? ????? ?1?)
	rjmp return_ascii ; ?????????? ?? ??? ?????????? r24 ??? ASCII ???? ??? D.
	ldi r24 ,'7'
	sbrc r26 ,4
	rjmp return_ascii
	ldi r24 ,'8'
	sbrc r26 ,5
	rjmp return_ascii
	ldi r24 ,'9'
	sbrc r26 ,6
	rjmp return_ascii ;
	ldi r24 ,'C'
	sbrc r26 ,7
	rjmp return_ascii
	ldi r24 ,'4' ; ?????? ?1? ???? ?????? ??? ?????????? r27 ????????
	sbrc r27 ,0 ; ?? ???????? ??????? ??? ????????
	rjmp return_ascii
	ldi r24 ,'5'
	sbrc r27 ,1
	rjmp return_ascii
	ldi r24 ,'6'
	sbrc r27 ,2
	rjmp return_ascii
	ldi r24 ,'B'
	sbrc r27 ,3
	rjmp return_ascii
	ldi r24 ,'1'
	sbrc r27 ,4
	rjmp return_ascii ;
	ldi r24 ,'2'
	sbrc r27 ,5
	rjmp return_ascii
	ldi r24 ,'3'
	sbrc r27 ,6
	rjmp return_ascii
	ldi r24 ,'A'
	sbrc r27 ,7
	rjmp return_ascii
	clr r24
	rjmp return_ascii
	return_ascii:
	pop r27 ; ????????? ???? ??????????? r27:r26
	pop r26
ret

write_2_nibbles_sim:
	push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
	push r25 ; ?????????? ??? ???????????? ??????????????
	ldi r24 ,low(6000) ; ?????????
	ldi r25 ,high(6000)
	rcall wait_usec
	pop r25
	pop r24 ; ????? ????? ??????
	push r24 ; ??????? ?? 4 MSB
	in r25, PIND ; ??????????? ?? 4 LSB ??? ?? ?????????????
	andi r25, 0x0f ; ??? ?? ??? ????????? ??? ????? ??????????? ?????????
	andi r24, 0xf0 ; ????????????? ?? 4 MSB ???
	add r24, r25 ; ???????????? ?? ?? ???????????? 4 LSB
	out PORTD, r24 ; ??? ???????? ???? ?????
	sbi PORTD, PD3 ; ????????????? ?????? Enable ???? ????????? PD3
	cbi PORTD, PD3 ; PD3=1 ??? ???? PD3=0
	push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
	push r25 ; ?????????? ??? ???????????? ??????????????
	ldi r24 ,low(6000) ; ?????????
	ldi r25 ,high(6000)
	rcall wait_usec
	pop r25
	pop r24 ; ????? ????? ??????
	pop r24 ; ??????? ?? 4 LSB. ????????? ?? byte.
	swap r24 ; ????????????? ?? 4 MSB ?? ?? 4 LSB
	andi r24 ,0xf0 ; ??? ?? ??? ????? ???? ?????????????
	add r24, r25
	out PORTD, r24
	sbi PORTD, PD3 ; ???? ?????? Enable
	cbi PORTD, PD3
ret

lcd_data_sim:
	push r24 ; ?????????? ???? ??????????? r25:r24 ????? ????
	push r25 ; ????????? ???? ??? ???????
	sbi PORTD, PD2 ; ??????? ??? ?????????? ????????? (PD2=1)
	rcall write_2_nibbles_sim ; ???????? ??? byte
	ldi r24 ,43 ; ??????? 43?sec ????? ?? ??????????? ? ????
	ldi r25 ,0 ; ??? ????????? ??? ??? ??????? ??? lcd
	rcall wait_usec
	pop r25 ;????????? ???? ??????????? r25:r24
	pop r24
ret

lcd_command_sim:
	push r24 ; ?????????? ???? ??????????? r25:r24 ????? ????
	push r25 ; ????????? ???? ??? ???????
	cbi PORTD, PD2 ; ??????? ??? ?????????? ??????? (PD2=0)
	rcall write_2_nibbles_sim ; ???????? ??? ??????? ??? ??????? 39?sec
	ldi r24, 39 ; ??? ??? ?????????? ??? ????????? ??? ??? ??? ??????? ??? lcd.
	ldi r25, 0 ; ???.: ???????? ??? ???????, ?? clear display ??? return home,
	rcall wait_usec ; ??? ???????? ????????? ?????????? ??????? ????????.
	pop r25 ; ????????? ???? ??????????? r25:r24
	pop r24
ret

lcd_init_sim:
	push r24 ; ?????????? ???? ??????????? r25:r24 ????? ????
	push r25 ; ????????? ???? ??? ???????

	ldi r24, 40 ; ???? ? ???????? ??? lcd ????????????? ??
	ldi r25, 0 ; ????? ??????? ??? ???? ??? ????????????.
	rcall wait_msec ; ??????? 40 msec ????? ???? ?? ???????????.
	ldi r24, 0x30 ; ?????? ????????? ?? 8 bit mode
	out PORTD, r24 ; ?????? ??? ???????? ?? ??????? ???????
	sbi PORTD, PD3 ; ??? ?? ?????????? ??????? ??? ???????
	cbi PORTD, PD3 ; ??? ??????, ? ?????? ???????????? ??? ?????
	ldi r24, 39
	ldi r25, 0 ; ??? ? ???????? ??? ?????? ????????? ?? 8-bit mode
	rcall wait_usec ; ??? ?? ?????? ??????, ???? ?? ? ???????? ???? ??????????
	 ; ??????? 4 bit ?? ??????? ?? ?????????? 8 bit
	push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
	push r25 ; ?????????? ??? ???????????? ??????????????
	ldi r24,low(1000) ; ?????????
	ldi r25,high(1000)
	rcall wait_usec
	pop r25
	pop r24 ; ????? ????? ??????
	ldi r24, 0x30
	out PORTD, r24
	sbi PORTD, PD3
	cbi PORTD, PD3
	ldi r24,39
	ldi r25,0
	rcall wait_usec
	push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
	push r25 ; ?????????? ??? ???????????? ??????????????
	ldi r24 ,low(1000) ; ?????????
	ldi r25 ,high(1000)
	rcall wait_usec
	pop r25
	pop r24 ; ????? ????? ??????
	ldi r24,0x20 ; ?????? ?? 4-bit mode
	out PORTD, r24
	sbi PORTD, PD3
	cbi PORTD, PD3
	ldi r24,39
	ldi r25,0
	rcall wait_usec
	push r24 ; ????? ?????? ??? ??????????? ??? ?? ?????
	push r25 ; ?????????? ??? ???????????? ??????????????
	ldi r24 ,low(1000) ; ?????????
	ldi r25 ,high(1000)
	rcall wait_usec
	pop r25
	pop r24 ; ????? ????? ??????
	ldi r24,0x28 ; ??????? ?????????? ???????? 5x8 ????????
	rcall lcd_command_sim ; ??? ???????? ??? ??????? ???? ?????
	ldi r24,0x0c ; ???????????? ??? ??????, ???????? ??? ???????
	rcall lcd_command_sim
	ldi r24,0x01 ; ?????????? ??? ??????
	rcall lcd_command_sim
	ldi r24, low(1530)
	ldi r25, high(1530)
	rcall wait_usec
	ldi r24 ,0x06 ; ???????????? ????????? ??????? ???? 1 ??? ??????????
	rcall lcd_command_sim ; ??? ????? ???????????? ???? ??????? ??????????? ???
	 ; ?????????????? ??? ????????? ????????? ??? ??????
	pop r25 ; ????????? ???? ??????????? r25:r24
	pop r24
ret

ADC_init:   ;ADC converter initialization
  ldi r24,(1<<REFS0) ; Vref: 5V
  out ADMUX,r24
  ;ADC is Enabled (ADEN=1)
  ;ADC Interrupts are Enabled (ADIE=1)
  ;Set Division Factor CK/128 = 62.5Khz (ADPS2:0=111)
  ldi r24,(1<<ADEN)|(1<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0)
  out ADCSRA,r24
ret

ISR_TIMER1_OVF:
  push r24
  in r24,ADCSRA ;Read register values
  ori r24,(1<<ADSC)
  out ADCSRA, r24 ;keeping preassigned register values insert ADC start bit
  ldi r24,0xfc
  out TCNT1H ,r24
  ldi r24 ,0xf3
  out TCNT1L ,r24 ;reset timer with value 0.1sec
  pop r24
  reti

ADC_ISR:
  ; ADC = ((Cx/77.5) + 0.1) * 204.8 with rounding

  ;keep in mind max ADC we read is 1023 which is 0x03FF in hex aka r5 = 0000 0011, r4 = 1111 1111

  push r24
  push r25
  push r26
  clr r26
  in r24, ADCL ;the result of the ADC is stored in 25:24
  in r25, ADCH

  andi r25,0x03 ;keep the 2 lsbs of r25 since result is 8 bits
  cpi r25, 0x02     ; 182 < ppm < 255
  brsh seven_led_state
  cpi r25, 0x01     ; 87 < ppm < 183
  brsh six_led_state
  cpi r24, 0xD0     ; 69 < ppm < 88
  brsh five_led_state
  cpi r24, 0x90     ; 45 < ppm < 70
  brsh four_led_state
  cpi r24,0x76      ; 35 < ppm < 46
  brsh three_led_state
  cpi r24,0x45      ; 17 < ppm < 36
  brsh two_led_state
  cpi r24,0x18      ; 1 <= ppm < 18
  brsh one_led
  one_led:
    ldi r26, 0x01
    rjmp show_led_state
  two_led_state:
    ldi r26, 0x03
    rjmp show_led_state
  three_led_state:
    ldi r26, 0x07
    rjmp show_led_state
  four_led_state:
    ldi r26, 0x0F
    rjmp show_led_state
  five_led_state:
    ldi r26, 0x1F
    rjmp show_led_state
  six_led_state:
    ldi r26, 0x3F
    rjmp show_led_state
  seven_led_state:   ; ppm >=140
    ldi r26, 0x7F
    rjmp show_led_state

  show_led_state:
    andi r17,0x80
    or r17,r26
    out PORTB,r17 ;display it in PORTB 
    sbrc welcome_active,0 ;if lsb of welcome_active is set, then we are during welcome message so we keep led on (without blinking if CO was above level)
    jmp exit ;even if CO was above level we think it is good practice to keep it that way

    cpi r26,0x1F  ;else, check if level below 5th bit indicating < 70 ppm
    brcs clear  ;if yes it's clear

    cpi blink_state,0x01 ;else check if the previous check indicated danger and the led
    breq on_off

    cpi blink_state,0x03 ;check if the previous check indicated danger and the led was off
    breq on_ex

    ldi blink_state,0x01 ;else if the previous check was ok, set 1st bit of blink_state
    display_gas ;display gas message
    jmp exit

    on_off:
      ori blink_state,0x02 ;set blink_state as led is on and previous state was >==70ppm
      andi r17,0x80 ;keep only 8th bit of led_state
      out PORTB, r17 ;in order to turn off led of level of gas
      jmp exit

    on_ex:
      andi blink_state,0xFD  ;clear 2nd bit of blink_state to display concentration level on next
      jmp exit


    clear:
      cpi blink_state,0x00 ;check if previous check was also clear so as not to display
      breq exit
      ldi blink_state,0x00 ;clear blink_state to show safe level of gas
      display_clear ;display clear message
  exit:
  pop r26
  pop r25
  pop r24
reti
